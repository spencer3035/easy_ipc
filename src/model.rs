use {
    crate::{client::Client, connection::Connection, error::InitError, server::Server},
    interprocess::local_socket::{
        GenericFilePath, GenericNamespaced, ListenerOptions, Stream, prelude::*,
    },
    serde::{Deserialize, Serialize},
};

pub type Name = interprocess::local_socket::Name<'static>;

/// Default name of socket
// TODO: Probably need to have this generated by a macro on implementing crates
pub fn default_socket_name() -> Name {
    if GenericNamespaced::is_supported() {
        "example.sock".to_ns_name::<GenericNamespaced>().unwrap()
    } else {
        "/home/spencer/example.sock"
            .to_fs_name::<GenericFilePath>()
            .unwrap()
    }
}

/// A model for a Client Server IPC interface. Client messages are denoted by the generic `C` and
/// server messages are denoted by the generic `S`.
pub trait ClientServerModel<C, S>
where
    C: Serialize + for<'de> Deserialize<'de>,
    S: Serialize + for<'de> Deserialize<'de>,
{
    /// The location that the socket will be stored. Can be overwriten if the default location is
    /// not desired. See [`default_socket_name`].
    fn socket_name() -> Name {
        default_socket_name()
    }

    /// Make a new client, errors if unable to connect to server. Should not be implemented
    /// manually.
    fn client() -> Result<Client<C, S>, InitError> {
        let name = Self::socket_name();
        let stream = Stream::connect(name).map_err(|e| InitError::FailedConnectingToSocket(e))?;
        let conn = Connection::new(stream);
        Ok(Client::new(conn))
    }

    /// Try to create a new server instance. Needs to be created before clients. Should not be
    /// implemented manually
    fn server() -> Result<Server<S, C>, InitError> {
        let name = Self::socket_name();
        let opts = ListenerOptions::new().name(name);
        // Can fail for IO reasons
        let listener = opts.create_sync().map_err(|e| match e {
            // Server is already running on the socket or the cleanup of the file failed
            e if e.kind() == std::io::ErrorKind::AddrInUse => InitError::SocketAlreadyExists,
            e => InitError::FailedConnectingToSocket(e),
        })?;
        Ok(Server::new(listener))
    }
}
